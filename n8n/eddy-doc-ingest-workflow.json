{
  "name": "EDDY Doc Ingest",
  "nodes": [
    {
      "parameters": {},
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [100, 400],
      "id": "727dd4e0-547e-414e-95e2-8a23d734d892"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "eddy/doc-ingest",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "name": "ğŸŒ Webhook Ingest",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [100, 700],
      "webhookId": "eddy-doc-ingest-00000010",
      "id": "f5d9864e-fcd1-45a4-9973-08aa90ecb9bd"
    },
    {
      "parameters": {
        "jsCode": "// Scan /home/node/eddy-inbox/pending/ fÃ¼r neue Dokumente\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\n\nconst INBOX_DIR = '/home/node/eddy-inbox/pending';\nconst SUPPORTED_TYPES = ['.pdf', '.txt', '.md', '.docx'];\n\ntry {\n  if (!fs.existsSync(INBOX_DIR)) {\n    return [{ json: { error: 'Inbox directory not found', path: INBOX_DIR, files: [] } }];\n  }\n\n  const files = fs.readdirSync(INBOX_DIR)\n    .filter(f => {\n      const ext = path.extname(f).toLowerCase();\n      return SUPPORTED_TYPES.includes(ext) && !f.startsWith('.');\n    })\n    .map(f => {\n      const filePath = path.join(INBOX_DIR, f);\n      const stats = fs.statSync(filePath);\n      const fileBuffer = fs.readFileSync(filePath);\n      const fileHash = crypto.createHash('sha256').update(fileBuffer).digest('hex');\n      const ext = path.extname(f).toLowerCase().replace('.', '');\n      \n      return {\n        json: {\n          fileName: f,\n          filePath: filePath,\n          sourceType: ext,\n          fileHash: fileHash,\n          fileSize: stats.size,\n          modifiedAt: stats.mtime.toISOString()\n        }\n      };\n    });\n\n  if (files.length === 0) {\n    return [{ json: { status: 'empty', message: 'No new files in inbox' } }];\n  }\n\n  return files;\n} catch (err) {\n  return [{ json: { error: err.message } }];\n}"
      },
      "name": "ğŸ“‚ Scan Inbox",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [340, 400],
      "id": "4a4defd7-9a41-4f2f-9280-fce1e64b6cd0"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "combinator": "and",
          "conditions": [
            {
              "leftValue": "={{ $json.fileName }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            }
          ]
        },
        "looseTypeValidation": true
      },
      "name": "ğŸ“‹ Has Files?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [560, 400],
      "id": "389d0d2c-d898-42f9-89f7-66e593216278"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM check_file_ingested($1);",
        "options": {
          "queryReplacement": "={{ [$json.fileHash] }}"
        }
      },
      "name": "ğŸ” Duplikat-Check",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [780, 400],
      "credentials": {
        "postgres": {
          "id": "Jq2IeHXVMOnpk0fI",
          "name": "eddy-knowledge-postgres"
        }
      },
      "id": "a9113e43-9ecc-40cf-9d3f-72a1120c712d"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "leftValue": "={{ $json.is_ingested }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "notTrue"
              }
            }
          ]
        }
      },
      "name": "ğŸ†• Noch nicht ingestiert?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [1000, 400],
      "id": "9e35ee71-f7c4-4d20-8119-c05abcc21ab7"
    },
    {
      "parameters": {
        "jsCode": "// Text-Extraktion basierend auf Dateityp\nconst fs = require('fs');\nconst { execSync } = require('child_process');\n\nconst filePath = $('ğŸ“‹ Has Files?').first().json.filePath;\nconst sourceType = $('ğŸ“‹ Has Files?').first().json.sourceType;\nconst fileName = $('ğŸ“‹ Has Files?').first().json.fileName;\nconst fileHash = $('ğŸ“‹ Has Files?').first().json.fileHash;\nconst modifiedAt = $('ğŸ“‹ Has Files?').first().json.modifiedAt;\n\nlet content = '';\n\ntry {\n  if (sourceType === 'txt' || sourceType === 'md') {\n    content = fs.readFileSync(filePath, 'utf-8');\n  } else if (sourceType === 'pdf') {\n    // pdf-parse in eigenem Node-Prozess (n8n Sandbox freezt Prototypen)\n    const result = execSync(\n      'node /home/node/eddy-inbox/scripts/pdf-extract.js \"' + filePath.replace(/\"/g, '\\\\\"') + '\"',\n      { timeout: 30000, encoding: 'utf-8', maxBuffer: 10 * 1024 * 1024 }\n    );\n    const parsed = JSON.parse(result.trim());\n    if (parsed.error) throw new Error('PDF parse: ' + parsed.error);\n    content = parsed.text || '';\n  } else if (sourceType === 'docx') {\n    content = '[DOCX extraction not yet supported]';\n  }\n\n  if (!content || content.trim().length < 10) {\n    return [{ json: { error: 'No content extracted', fileName, sourceType } }];\n  }\n\n  return [{\n    json: {\n      content: content.trim(),\n      fileName, filePath, sourceType, fileHash, modifiedAt,\n      contentLength: content.trim().length\n    }\n  }];\n} catch (err) {\n  return [{ json: { error: err.message, fileName, sourceType } }];\n}"
      },
      "name": "ğŸ“„ Text Extraction",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1220, 400],
      "id": "34de3c90-2b5b-4125-9935-61cb42459a41"
    },
    {
      "parameters": {
        "jsCode": "// Chunking mit Overlap\nconst CHUNK_SIZE = 800;     // ~500 Token\nconst OVERLAP = 320;        // ~200 Token\n\nconst content = $json.content || '';\nconst fileName = $json.fileName;\nconst sourceType = $json.sourceType;\nconst fileHash = $json.fileHash;\nconst modifiedAt = $json.modifiedAt;\n\nconst crypto = require('crypto');\n\nif (!content || content.length < 10) {\n  return [{ json: { error: 'No content to chunk', fileName } }];\n}\n\nconst chunks = [];\nlet startIndex = 0;\nlet chunkIndex = 0;\n\nwhile (startIndex < content.length) {\n  let endIndex = Math.min(startIndex + CHUNK_SIZE, content.length);\n  \n  // Versuche am Satzende zu brechen\n  if (endIndex < content.length) {\n    const lastPeriod = content.lastIndexOf('.', endIndex);\n    const lastNewline = content.lastIndexOf('\\n', endIndex);\n    const breakPoint = Math.max(lastPeriod, lastNewline);\n    if (breakPoint > startIndex + CHUNK_SIZE * 0.5) {\n      endIndex = breakPoint + 1;\n    }\n  }\n  \n  const chunkText = content.slice(startIndex, endIndex).trim();\n  \n  if (chunkText.length > 20) {\n    const chunkHash = crypto.createHash('sha256').update(chunkText).digest('hex');\n    chunks.push({\n      json: {\n        chunk_content: chunkText,\n        chunk_hash: chunkHash,\n        chunk_index: chunkIndex,\n        source_file: fileName,\n        source_type: sourceType,\n        file_hash: fileHash,\n        modified_at: modifiedAt\n      }\n    });\n    chunkIndex++;\n  }\n  \n  if (endIndex >= content.length) break;\n  startIndex = endIndex - OVERLAP;\n}\n\nconst totalChunks = chunks.length;\nchunks.forEach(c => c.json.total_chunks = totalChunks);\n\nreturn chunks;"
      },
      "name": "ğŸ”ª Chunking (800/320)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1440, 400],
      "id": "283113a0-6323-48a7-9762-8e53a2f63355"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://n8n-ollama:11434/api/embeddings",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'mxbai-embed-large', prompt: 'search_document: ' + $json.chunk_content }) }}",
        "options": {
          "timeout": 60000
        }
      },
      "name": "ğŸ§¬ Embedding (mxbai)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1660, 400],
      "id": "78467c42-1ba9-4e5c-adc2-063e3296db8b"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO document_chunks (content, content_hash, embedding, source_file, source_type, file_hash, chunk_index, total_chunks, source_modified_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) ON CONFLICT (content_hash) DO NOTHING RETURNING id;",
        "options": {
          "queryReplacement": "={{ [$node['ğŸ”ª Chunking (800/320)'].json.chunk_content, $node['ğŸ”ª Chunking (800/320)'].json.chunk_hash, '[' + $json.embedding.join(',') + ']', $node['ğŸ”ª Chunking (800/320)'].json.source_file, $node['ğŸ”ª Chunking (800/320)'].json.source_type, $node['ğŸ”ª Chunking (800/320)'].json.file_hash, $node['ğŸ”ª Chunking (800/320)'].json.chunk_index, $node['ğŸ”ª Chunking (800/320)'].json.total_chunks, $node['ğŸ”ª Chunking (800/320)'].json.modified_at] }}"
        }
      },
      "name": "ğŸ’¾ Store in pgvector",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1880, 400],
      "credentials": {
        "postgres": {
          "id": "Jq2IeHXVMOnpk0fI",
          "name": "eddy-knowledge-postgres"
        }
      },
      "id": "98c54b9f-074d-4739-88be-1c3888c9ed61"
    },
    {
      "parameters": {
        "jsCode": "// Datei von pending nach processed verschieben\nconst fs = require('fs');\nconst path = require('path');\n\nconst filePath = $('ğŸ“‹ Has Files?').first().json.filePath;\nconst fileName = $('ğŸ“‹ Has Files?').first().json.fileName;\nconst processedDir = '/home/node/eddy-inbox/processed';\n\ntry {\n  if (!fs.existsSync(processedDir)) {\n    fs.mkdirSync(processedDir, { recursive: true });\n  }\n  \n  const dest = path.join(processedDir, fileName);\n  fs.renameSync(filePath, dest);\n  \n  return [{\n    json: {\n      status: 'success',\n      fileName,\n      movedTo: dest,\n      chunks_created: $items().length\n    }\n  }];\n} catch (err) {\n  const failedDir = '/home/node/eddy-inbox/failed';\n  try {\n    if (!fs.existsSync(failedDir)) fs.mkdirSync(failedDir, { recursive: true });\n    fs.renameSync(filePath, path.join(failedDir, fileName));\n  } catch (e) { /* ignore */ }\n  \n  return [{ json: { status: 'error', error: err.message, fileName } }];\n}"
      },
      "name": "ğŸ“ Move to Processed",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2100, 400],
      "id": "c95c59f6-3ca6-4482-8631-8ee07cd232f8"
    },
    {
      "parameters": {
        "jsCode": "// Webhook-Pfad: Content direkt chunken\nconst crypto = require('crypto');\n\nconst content = $json.body.content || '';\nconst metadata = $json.body.metadata || {};\nconst fileName = metadata.source_file || 'webhook-input';\nconst sourceType = metadata.source_type || 'txt';\nconst category = metadata.category || null;\nconst tags = metadata.tags || [];\nconst fileHash = crypto.createHash('sha256').update(content).digest('hex');\n\nconst CHUNK_SIZE = 800;\nconst OVERLAP = 320;\n\nif (!content || content.trim().length < 10) {\n  return [{ json: { error: 'No content provided' } }];\n}\n\nconst chunks = [];\nlet startIndex = 0;\nlet chunkIndex = 0;\nconst trimmed = content.trim();\n\nwhile (startIndex < trimmed.length) {\n  let endIndex = Math.min(startIndex + CHUNK_SIZE, trimmed.length);\n  \n  if (endIndex < trimmed.length) {\n    const lastPeriod = trimmed.lastIndexOf('.', endIndex);\n    const lastNewline = trimmed.lastIndexOf('\\n', endIndex);\n    const breakPoint = Math.max(lastPeriod, lastNewline);\n    if (breakPoint > startIndex + CHUNK_SIZE * 0.5) {\n      endIndex = breakPoint + 1;\n    }\n  }\n  \n  const chunkText = trimmed.slice(startIndex, endIndex).trim();\n  \n  if (chunkText.length > 20) {\n    const chunkHash = crypto.createHash('sha256').update(chunkText).digest('hex');\n    chunks.push({\n      json: {\n        chunk_content: chunkText,\n        chunk_hash: chunkHash,\n        chunk_index: chunkIndex,\n        source_file: fileName,\n        source_type: sourceType,\n        file_hash: fileHash,\n        category: category,\n        tags: tags\n      }\n    });\n    chunkIndex++;\n  }\n  \n  if (endIndex >= trimmed.length) break;\n  startIndex = endIndex - OVERLAP;\n}\n\nconst totalChunks = chunks.length;\nchunks.forEach(c => c.json.total_chunks = totalChunks);\n\nreturn chunks;"
      },
      "name": "ğŸ”ª Webhook Chunking",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [340, 700],
      "id": "d6bf7c64-b07c-411b-a583-ade8afc71816"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://n8n-ollama:11434/api/embeddings",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'mxbai-embed-large', prompt: 'search_document: ' + $json.chunk_content }) }}",
        "options": {
          "timeout": 60000
        }
      },
      "name": "ğŸ§¬ WH Embedding",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [560, 700],
      "id": "440b24c4-74e6-41ba-bd0f-91bc6e070f9b"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO document_chunks (content, content_hash, embedding, source_file, source_type, file_hash, chunk_index, total_chunks, category, tags) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) ON CONFLICT (content_hash) DO NOTHING RETURNING id;",
        "options": {
          "queryReplacement": "={{ [$node['ğŸ”ª Webhook Chunking'].json.chunk_content, $node['ğŸ”ª Webhook Chunking'].json.chunk_hash, '[' + $json.embedding.join(',') + ']', $node['ğŸ”ª Webhook Chunking'].json.source_file, $node['ğŸ”ª Webhook Chunking'].json.source_type, $node['ğŸ”ª Webhook Chunking'].json.file_hash, $node['ğŸ”ª Webhook Chunking'].json.chunk_index, $node['ğŸ”ª Webhook Chunking'].json.total_chunks, $node['ğŸ”ª Webhook Chunking'].json.category || null, $node['ğŸ”ª Webhook Chunking'].json.tags ? '{' + $node['ğŸ”ª Webhook Chunking'].json.tags.join(',') + '}' : null] }}"
        }
      },
      "name": "ğŸ’¾ WH Store",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [780, 700],
      "credentials": {
        "postgres": {
          "id": "Jq2IeHXVMOnpk0fI",
          "name": "eddy-knowledge-postgres"
        }
      },
      "id": "8a0362d7-f1c6-4110-9e60-d3e9e413f854"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { status: 'success', chunks_ingested: $items().length, source: $node['ğŸ”ª Webhook Chunking'].first().json.source_file } }}",
        "options": {}
      },
      "name": "âœ… WH Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1000, 700],
      "id": "c2f848b1-57e3-42b7-8b0c-0ab9bccb8b1a"
    }
  ],
  "connections": {
    "ğŸ“‚ Scan Inbox": {
      "main": [[{"node": "ğŸ“‹ Has Files?", "type": "main", "index": 0}]]
    },
    "ğŸ“‹ Has Files?": {
      "main": [[{"node": "ğŸ” Duplikat-Check", "type": "main", "index": 0}], []]
    },
    "ğŸ” Duplikat-Check": {
      "main": [[{"node": "ğŸ†• Noch nicht ingestiert?", "type": "main", "index": 0}]]
    },
    "ğŸ†• Noch nicht ingestiert?": {
      "main": [[], [{"node": "ğŸ“„ Text Extraction", "type": "main", "index": 0}]]
    },
    "ğŸ“„ Text Extraction": {
      "main": [[{"node": "ğŸ”ª Chunking (800/320)", "type": "main", "index": 0}]]
    },
    "ğŸ”ª Chunking (800/320)": {
      "main": [[{"node": "ğŸ§¬ Embedding (mxbai)", "type": "main", "index": 0}]]
    },
    "ğŸ§¬ Embedding (mxbai)": {
      "main": [[{"node": "ğŸ’¾ Store in pgvector", "type": "main", "index": 0}]]
    },
    "ğŸ’¾ Store in pgvector": {
      "main": [[{"node": "ğŸ“ Move to Processed", "type": "main", "index": 0}]]
    },
    "ğŸŒ Webhook Ingest": {
      "main": [[{"node": "ğŸ”ª Webhook Chunking", "type": "main", "index": 0}]]
    },
    "ğŸ”ª Webhook Chunking": {
      "main": [[{"node": "ğŸ§¬ WH Embedding", "type": "main", "index": 0}]]
    },
    "ğŸ§¬ WH Embedding": {
      "main": [[{"node": "ğŸ’¾ WH Store", "type": "main", "index": 0}]]
    },
    "ğŸ’¾ WH Store": {
      "main": [[{"node": "âœ… WH Response", "type": "main", "index": 0}]]
    },
    "Manual Trigger": {
      "main": [[{"node": "ğŸ“‚ Scan Inbox", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "eddy-doc-ingest"
  }
}
